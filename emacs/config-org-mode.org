* Org Mode
#+begin_src emacs-lisp :results none
  (use-package org)
  (require 'org-id)
#+end_src

** Screen
#+begin_src emacs-lisp :results none
  (setq org-return-follows-link t)

  (add-hook 'org-mode-hook (lambda ()
                             ;; make the lines in the buffer wrap around the edges of the screen.
                             (visual-line-mode)
                             (org-indent-mode)))
  (use-package valign)
#+end_src

** Keybindings
#+begin_src emacs-lisp :results none
  (gn/leader-nvmap org-mode-map
    "e" 'org-ctrl-c-ctrl-c
    "bb" 'gn/org-open-scope
    )

  (gn/leader-nmap org-mode-map
    "a" 'org-agenda
    "c" 'org-capture
    "i" '(:ignore i :which-key "insert")
    "id" '(:ignore id :which-key "date")
    "id SPC" 'org-time-stamp
    "idi" 'org-time-stamp-inactive
    "idd" 'org-deadline
    "ids" 'org-schedule
    "il" 'org-insert-link
    "ii" 'org-id-get-create
    "it" 'org-insert-structure-template
    "iT" 'gn/org-insert-template
    "D" 'org-cut-subtree
    "y" '(:ignore y :which-key "yank")
    "yi" 'org-id-copy
    "yl" 'org-store-link
    "t" '(:ignore t :which-key "toggle")
    "T" 'gn/toggle-todo
    "tt" 'org-todo
    "tl" 'org-toggle-link-display
    "ti" 'org-toggle-inline-images
    "s" '(:ignore s :which-key "src")
    "st" 'org-babel-tangle
    "/" 'org-sparse-tree
    )

  (general-define-key
   :states '(normal visual insert)
   :keymaps 'org-mode-map
   "C-<return>" 'gn/org-insert-new-item
   "C-h" 'gn/org-promote-tree
   "C-S-h" 'gn/org-promote
   "C-j" 'gn/org-move-tree-down
   "C-k" 'gn/org-move-tree-up
   "C-l" 'gn/org-demote-tree
   "C-S-l" 'gn/org-demote
   )

  (general-nvmap
    :keymaps 'org-mode-map
    "J" 'org-next-visible-heading
    "K" 'org-previous-visible-heading)
#+end_src

   
** Movement
#+begin_src emacs-lisp :results none
  (define-minor-mode gn/org-movement-mode
    "Minor mode for org movements"
    :lighter " gn/org-movement"
    )

  ;(general-nvmap org-mode-map
  ;  "C-k" 'org-previous-visible-heading
  ;  "C-j" 'org-next-visible-heading
  ;  )
#+end_src

** Editing
#+begin_src emacs-lisp :results none
      (defun gn/org-insert-new-item ()
        "Inserts a new item (headings, checkboxes, or bullets)"
        (interactive)
        (evil-append-line 0)
        (cond ((org-at-heading-p) (org-insert-heading-respect-content)) 
              ((org-at-item-checkbox-p) (org-insert-todo-heading nil))
              ((org-at-item-p) (org-insert-item))))

      (defun gn/org-promote ()
        "Moves item position (headings, checkboxes, or bullets)"
        (interactive)
        (cond ((org-at-heading-p) (org-do-promote))
              ((org-at-item-p) (org-outdent-item))))

      (defun gn/org-promote-tree ()
        "Moves item position (headings, checkboxes, or bullets)"
        (interactive)
        (cond ((org-at-heading-p) (org-promote-subtree))
              ((org-at-item-p) (org-outdent-item-tree))))

      (defun gn/org-demote ()
        "Demotes item (headings, lists)"
        (interactive)
        (cond ((org-at-heading-p) (org-do-demote))
              ((org-at-item-p) (org-indent-item))))

      (defun gn/org-demote-tree ()
        "Demotes item (headings, lists)"
        (interactive)
        (cond ((org-at-heading-p) (org-demote-subtree))
              ((org-at-item-p) (org-indent-item-tree))))

      (defun gn/org-demote-tree ()
        "Demotes item (headings, lists)"
        (interactive)
        (cond ((org-at-heading-p) (org-demote-subtree))
              ((org-at-item-p) (org-indent-item-tree))))

      (defun gn/org-move-tree-up ()
        "Moves item up (headings, lists)"
        (interactive)
        (cond ((org-at-heading-p) (org-move-subtree-up))
              ((org-at-item-p) (org-move-item-up))))

      (defun gn/org-move-tree-down ()
        "Moves item down (headings, lists)"
        (interactive)
        (cond ((org-at-heading-p) (org-move-subtree-down))
              ((org-at-item-p) (org-move-item-down))))

      (defun gn/org-open-scope ()
        "Open subtree or block in new buffer"
        (interactive)
        (cond ((org-in-src-block-p) (org-edit-special))
              ((org-at-heading-p) (org-tree-to-indirect-buffer))))

#+end_src
    
** Workflow
The problem I am facing
#+begin_src plantuml :tangle no
  @startuml
  title My Daily Workflow

  start
  :Review agenda;
  fork
          repeat
                  while (new information exists?) is (yes)
                          :Clarify|
                          :Organize|
                  endwhile (no)
                  :Execute|
          repeat while (still working?) is (yes)
          ->no;
  fork again
          repeat  
                  :await new information;
                  :Capture|
          repeat while (still working?) is (yes)
          ->no;
  end fork

  :Plan for next workday;
  stop
  @enduml
#+end_src

#+begin_src emacs-lisp :results one
  (defvar gn/inbox-path "~/myworkflow/inbox.org"
    "Path to the inbox file")

  (defvar gn/todo-path "~/myworkflow/todo.org"
    "Path to the todo file")

  (defvar gn/reference-path "~/myworkflow/reference.org"
    "Path to the reference file")

  (defvar gn/incubator-path "~/myworkflow/incubator.org"
    "Path to the incubator file")
#+end_src
*** Capture
#+begin_src plantuml :tangle no
  @startuml
  title Capture

  start
  split
          :check email;
  split again
          :check Slack;
  split again
          :check ChatWork;
  end split
  :store in **inbox**
  - new tasks
  - interesting information;
  stop
  @enduml
#+end_src

#+begin_src emacs-lisp :results none
  (setq org-capture-templates
        '(("i" "Inbox" entry (file gn/inbox-path "Inbox")
           "* %?")
          ))

  (setq org-refile-targets
        '((gn/inbox-path :level . 1)
          (gn/todo-path :level . 1)
          (gn/reference-path :level . 1)
          (gn/incubator-path :level . 1)
          ))

  (general-nmap org-capture-mode-map
    [remap save-buffer] 'org-capture-finalize
    [remap kill-current-buffer] 'org-capture-kill)
#+end_src

*** Clarify
#+begin_src plantuml :tangle no
  @startuml
  title Clarify

  start
  :item in inbox/
  if (is it actionable?) then (no)

  else (yes)
  endif
  if (can you do it in 2 min?) then (no)
          if ()
  else (yes)
          :do it now;
          stop
  endif

  stop
  @enduml
#+end_src
#+begin_src plantuml :tangle no
  @startuml
  title My Daily Workflow

  start
  :Review agenda;
  fork
          repeat
                  while (new information exists?\n- captured information\n- email\n- slack) is (yes)
                          :<b>Clarify</b>
                          - categorize information
                            (task, reference, future project)
                          - decide what the next task is
                            for the information|
                          :<b>Organize</b>
                          - schedule
                          - set priority|
                  endwhile (no)
                  :Execute|
                  note left
                          Do next task.
                  end note
          repeat while (still working?) is (yes)
          ->no;
  fork again
          repeat  
                  :<b>await new information</b>
                  Wait until new information
                  comes up.

                  E.g.
                  - someone talks to you
                  - you read an article
                    about something;
                  :Capture|
                  note left
                          Store new information.
                          E.g.
                          - new tasks
                          - ideas
                  end note
          repeat while (still working?) is (yes)
          ->no;
  end fork

  :Plan for next workday;
  stop
  @enduml
#+end_src

#+begin_src emacs-lisp :results none
  (setq org-todo-keywords
        '((sequence "TODO" "DOING" "|" "DONE")
          (sequence "ON-HOLD(o)" "SCHEDULED(s)" "WAITING(w)" "CANCELLED(c)")))

  (defun gn/next-todo (current-todo)
    "Returns next todo"
    (cond ((equal current-todo "TODO") "DOING")
          ((equal current-todo "ON-HOLD") "DOING")
          ((equal current-todo "SCHEDULED") "DOING")
          ((equal current-todo "WAITING") "DOING")
          ((equal current-todo "DOING") "DONE")))

  (defun gn/current-todo ()
    (if (org-entry-is-todo-p)
        (-> (org-get-todo-state)
          substring-no-properties)
      nil))

  (defun gn/toggle-todo ()
    "Toggle TODO states"
    (interactive)
    (org-todo (if (org-entry-is-todo-p) 
                  (gn/next-todo (gn/current-todo))
                "TODO"))
    (if (equal (gn/current-todo) "DOING")
        (org-clock-in)
      (org-clock-out)))
#+end_src

** Agenda
#+begin_src emacs-lisp :results none
       (evil-set-initial-state 'org-agenda-mode 'normal)

       (setq org-agenda-files '("~/todo/actions.org"))
       (setq org-agenda-log-mode-items '(state))
#+end_src

** Source Mode
#+begin_src emacs-lisp :results none
      (general-nmap org-src-mode-map
        [remap save-buffer] 'org-edit-src-exit
        [remap kill-current-buffer] 'org-edit-src-abort)

      ;; Don't confirm when evaluating src blocks
      (setq org-confirm-babel-evaluate nil)

#+end_src
** Template
#+begin_src emacs-lisp :results none
       (defvar gn/org-template-path "~/todo/templates.org")

       (defun gn/org-template ()
         ""
         (with-temp-buffer
           (insert-file-contents gn/org-template-path)
           (org-mode)
           (org-element-parse-buffer)))

       (defun gn/org-template-headlines (max-headline-level)
         "Get org template headlines

       MAX-HEADLINE-LEVEL is an integer that specifies how deep to search headlines"
         (org-element-map (gn/org-template) 'headline
           (lambda (h)
             (when (<= (org-element-property :level h)
                       max-headline-level)
               h))))

       (defvar gn/org-max-headline-level 2)

       (defun gn/org-insert-template ()
         (interactive)
         (let ((headlines (gn/org-template-headlines gn/org-max-headline-level)))
           (->> headlines
                (-map (lambda
                        (headline)
                        (org-element-property :raw-value headline)))
                (completing-read "Select a template: ")
                ((lambda (headline-raw-value)
                   (-first (lambda
                             (headline)
                             (string= headline-raw-value
                                      (org-element-property :raw-value headline)))
                           headlines)))
                (org-element-interpret-data)
                ((lambda (headline)
                   (save-excursion (insert headline)))))
           )
         )
#+end_src
** Getting Things Done
#+begin_src emacs-lisp :results none
#+end_src
     
** Org HTML Export
#+begin_src emacs-lisp :results none
  (require 'ox-html)

  (org-export-define-derived-backend 'gn-blog-post-vue 'html
    :options-alist '((:html_doctype "HTML_DOCTYPE" "HTML5" t)
                     (:html_container "HTML_CONTAINER" "div" t))
    :translate-alist '((template . gn/org-blog-post-template)))

                                          ;(org-publish-project "gn-publish" t)


                                          ;'(setq gn/test )
                                          ;'"./\\(?=.+?.\\(png\\|jpg\\)\\)" 
                                          ;'(replace-regexp-in-string "./\\(?=.+?png\\)" "something" "<img src='./tessting.png'")

  (defun gn/org-blog-post-template (contents info)
    "Template for org vue export"
    (concat
     "<template>\n"
     "<div>\n"
     contents
     "</div>\n"
     "</template>\n"
     "<script>\n"
     "export default {\n"
     (format "title: '%s',\n"
             (org-export-data (plist-get info :title) info))
     "meta: [\n"
     (format "{name: 'description', content: '%s'},"
             (org-export-data (plist-get info :description) info))
     "],\n"
     "}\n"
     "</script>\n"
     ))

  (defun gn/org-publish-as-blog-post
      (&optional async subtreep visible-only body-only ext-plist)
    (interactive)
    (org-export-to-buffer 'gn-blog-post-vue "*Org HTML Export*"
      async subtreep visible-only body-only ext-plist
      (lambda () (set-auto-mode t))))

  (defun gn/org-publish-blog-post-interactive
      (&optional async subtreep visible-only body-only ext-plist)
    (interactive)
    (unless (file-directory-p pub-dir)
      (make-directory pub-dir t))
    (let* ((extension ".vue")
           (file (org-export-output-file-name extension subtreep))
           (org-export-coding-system org-html-coding-system))
      (org-export-to-file 'gn-blog-post-vue file
        async subtreep visible-only body-only ext-plist)))

  (defun gn/org-publish-blog-post (plist filename pub-dir)
    (unless (file-directory-p pub-dir)
      (make-directory pub-dir t))
    (org-publish-org-to 'gn-blog-post-vue
                        filename
                        ".vue"
                        plist
                        pub-dir))

  (provide 'gn-blog-post-vue)

#+end_src
** TummyTracker
#+begin_src emacs-lisp :results none
  (org-export-define-derived-backend 'gn-tummytracker-entry 'html
    :options-alist '((:html_doctype "HTML_DOCTYPE" "HTML5" t)
                     (:html_container "HTML_CONTAINER" "div" t))
    :translate-alist '((template . gn/tummytracker-entry-template)))

  (defun gn/tummytracker-entry-template (contents info)
    "Template for org vue export"
    (concat
     "<template>\n"
     "<div>\n"
     contents
     "</div>\n"
     "</template>\n"
     "<script>\n"
     "export default {\n"
     "}\n"
     "</script>\n"
     ))

  (defun gn/tummytracker-publish-org-interactive
      (&optional async subtreep visible-only body-only ext-plist)
    (interactive)
    (unless (file-directory-p pub-dir)
      (make-directory pub-dir t))
    (let* ((extension ".vue")
           (file (org-export-output-file-name extension subtreep))
           (org-export-coding-system org-html-coding-system))
      (org-export-to-file 'gn-tummytracker-entry file
        async subtreep visible-only body-only ext-plist)))

  (defun gn/tummytracker-publish-org (plist filename pub-dir)
    (unless (file-directory-p pub-dir)
      (make-directory pub-dir t))
    (org-publish-org-to 'gn-tummytracker-entry
                        filename
                        ".vue"
                        plist
                        pub-dir))

  (provide 'gn-tummytracker-entry)
#+end_src

** Org HTML publishing
#+begin_src emacs-lisp :results none
  (setq org-publish-project-alist
        '(
          ("gn-publish" :components ("gn-publish-org" "gn-publish-static"))
          ("gn-publish-org"
           :base-directory "~/things/blog-posts/"
           :base-extension "org"
           :publishing-directory "~/things/web/pages/"
           :recursive t
           :publishing-function gn/org-publish-blog-post
           :headline-levels 4
           :auto-preamble t
           )
          ("gn-publish-static"
           :base-directory "~/things/blog-posts/"
           :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf"
           :publishing-directory "~/things/web/static/"
           :recursive t
           :publishing-function org-publish-attachment
           )

          ("gn-tummytracker-publish"
           :base-directory "~/tummytracker/entry/"
           :base-extension "org"
           :publishing-directory "~/tummytracker/app/src/pages/entry/"
           :recursive t
           :publishing-function gn/tummytracker-publish-org
           :headline-levels 4
           :auto-preamble t)
          ))
#+end_src


#+begin_src emacs-lisp :results none
#+end_src


